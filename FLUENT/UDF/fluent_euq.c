#include "udf.h"

/* UDF for performing EUQ in Fluent
 *
 */

/* Abid k-epsilon Turbulence model constants */
#define C_MU  0.09
#define SIG_K 1.0
#define SIG_D 1.4					/* 1.4  */
#define C1_D  1.45					/* 1.45 */
#define C2_D  1.83					/* 1.83 */
#define SMALL_NUMBER 1.0E-8
/* #define CUTOFF 0.2                double CUTOFF =  RP_Get_Real("uq/cutoff"); 					*/
/* #define COMPONENTIALITY 2         int COMPONENTIALITY = RP_Get_Integer("uq/componentiality");	*/
/* #define URLX 0.0                  double URLX =  RP_Get_Real("uq/shift");                    	*/
/*                                   double tke_perturbation = RP_Get_Real("uq/tke_perturbation");	*/
/*                                   double theta = RP_Get_Real("uq/theta_perturbation")*M_PI/180.0;*/
/*                                   double phi   = RP_Get_Real("uq/phi_perturbation")*M_PI/180.0;	*/
/*                                   double psi   = RP_Get_Real("uq/psi_perturbation")*M_PI/180.0;	*/

/* Holders for variables */
double abid_tke;					/* tke predicted by k-e model				*/
double abid_rsm[3][3];				/* reynolds stress generated by k-e model	*/
double new_tke;						/* new tke value							*/
double new_rsm[3][3];				/* perturbed								*/
double s_ij[3][3];					/* mean strain rate							*/
double delta_ij[3][3];				/* kroenecker delta							*/

/* Eigen-decomposition routines - QR Algorithm */
void eigen_decomposition(double A[3][3], double V[3][3], double d[3]);
static void tred2(double V[3][3], double d[3], double e[3]);
static void tql2(double V[3][3], double d[3], double e[3]);

/* Functions */
void compute_delta_ij(cell_t c, Thread *t);
void compute_abid_rsm_ij(cell_t c, Thread *t);
void compute_s_ij(cell_t c, Thread *t);
void compute_barycentric_map(cell_t c, Thread *t, double my_tke, double my_rsm[3][3]);

double ev(cell_t c, Thread *t);
double Re_y(cell_t c, Thread *t);
double Re_t(cell_t c, Thread *t);
double f_mu(cell_t c, Thread *t);
double f_1(cell_t c, Thread *t);
double f_2(cell_t c, Thread *t);
double f_switch(cell_t c, Thread *t);


/* User-defined scalars */
enum
{
	K, D,
	N_REQUIRED_UDS
};

/* User-defined memory storage*/
enum
{
	C1, C2, C3,                     /* barycentric colormap */
	D11, D12, D13, D22, D23, D33,
	R11, R12, R13, R22, R23, R33,
	SENSOR_00,
	N_REQUIRED_UDM
};


/*----------------------------------------------------------------*/
/* Abid k-epsilon turbulence model functions  - start             */
/*----------------------------------------------------------------*/

/* Reynolds number definitions */
double Re_y(cell_t c, Thread *t)
{
	double c_k;

	c_k = MAX(C_UDSI(c,t,K), SMALL_NUMBER);
	return C_R(c,t)*sqrt(c_k)*C_WALL_DIST(c,t)/C_MU_L(c,t);
}

double Re_t(cell_t c, Thread *t)
{
	double c_k, c_d;

	c_k = MAX(C_UDSI(c,t,K), SMALL_NUMBER);
	c_d = MAX(C_UDSI(c,t,D), SMALL_NUMBER);

	return C_R(c,t)*SQR(c_k)/C_MU_L(c,t)/c_d;
}

/* Abid Model Damping Function */
double f_mu(cell_t c, Thread *t)
{
	double my_fmu;

	my_fmu=tanh(0.008*Re_y(c,t))*(1.0+4.0/pow(MAX(Re_t(c,t),SMALL_NUMBER),0.75));

	C_UDMI(c,t,SENSOR_00) = my_fmu;
	return my_fmu;
}

/* Abid Model Damping Function */
double f_1(cell_t c, Thread *t)
{
	return 1.;
}

/* Abid Model Damping Function */
double f_2(cell_t c, Thread *t)
{
	return (1.0 - 2.0/9.0*exp(-MIN(Re_t(c,t)*Re_t(c,t)/36.0,10.0)))
			*(1.0 - exp(-MIN(Re_y(c,t)/12.0,10.0)));
} 

/* Set the turbulent viscosity */
double ev(cell_t c, Thread *t)
{
	double c_k = MAX(C_UDSI(c,t,K), SMALL_NUMBER);
	double c_d = MAX(C_UDSI(c,t,D), SMALL_NUMBER);


	return C_R(c,t)*C_MU*f_mu(c,t)*SQR(c_k)/c_d;
}

/* compute strain rate */
void compute_s_ij(cell_t c, Thread *t)
{
	s_ij[0][0] = C_DUDX(c,t);
	s_ij[1][1] = C_DVDY(c,t);
	s_ij[2][2] = C_DWDZ(c,t);
	s_ij[0][1] = 0.5 * (C_DUDY(c,t) + C_DVDX(c,t));
	s_ij[0][2] = 0.5 * (C_DUDZ(c,t) + C_DWDX(c,t));
	s_ij[1][2] = 0.5 * (C_DVDZ(c,t) + C_DWDY(c,t));
	s_ij[1][0] = s_ij[0][1];
	s_ij[2][1] = s_ij[1][2];
	s_ij[2][0] = s_ij[0][2];
}

/* define delta_ij tensor */
void compute_delta_ij(cell_t c, Thread *t) {
	int m,n;

	for (m=0; m<3; m++) {
		for (n=0; n<3; n++) {
			delta_ij[m][n] = 0.0;
		}
		delta_ij[m][m] = 1.0;
	}
}

void compute_abid_rsm_ij(cell_t c, Thread *t)
{
	int m,n;

	/* define the turbulent kinetic energy */
	abid_tke = MAX(C_UDSI(c,t,K), SMALL_NUMBER);

	compute_delta_ij(c,t);
	compute_s_ij(c,t);

	/* compute eddy viscosity-based Reynolds stresses */
	/* using the Boussinesq relationship (rho=const)  */

	for (m=0; m<3; m++) {
		for (n=0; n<3; n++) {
			double mu_t = ev(c,t);
			abid_rsm[m][n] = 2.0 / 3.0 * abid_tke * delta_ij[m][n] - 2.0 * mu_t / C_R(c,t) * s_ij[m][n];
		}
	}
}

double f_switch_0(cell_t c, Thread *t)
{
	return 0.0;
}

/* Sets the Sensor Region */
double f_switch(cell_t c, Thread *t)
{
	/* smooth transition between active (1) and inactive (0) */
	double CUTOFF =  RP_Get_Real("uq/cutoff");
	double my_z=50.0*(C_WALL_DIST(c,t)-CUTOFF);
	double my_switch = MAX(MIN(1.0,0.5-0.5*tanh(my_z)),0.0);
	/* smooth towards the symmetry planes.... */
	/*
  double xc[ND_ND];
  C_CENTROID(xc,c,t);
  double teta=atan(xc[2]/xc[1]);
  double sine_switch = sin(2.0*teta)*sin(2.0*teta);
  my_switch *=sine_switch;
	 */
	return my_switch;
}

/* Introduce Perturbations to turbulence stress tensor */
void compute_barycentric_map(cell_t c, Thread *t, double my_tke, double my_rsm[3][3]) {

	double a_ij[3][3],tmp[3][3],rotation_ij[3][3],new_eigv[3][3];
	int m,n,i,j,k;
	double eigv[3][3],eigs[3];
	double corner[3][3], bary_coordinates[3];

	/* define barycentric traingle corner points */
	corner[0][0] = 1.0;
	corner[0][1] = 0.0;
	corner[1][0] = 0.0;
	corner[1][1] = 0.0;
	corner[2][0] = 0.5;
	corner[2][1] = 0.866025;

	/* compute kroenecker delta */
	compute_delta_ij(c,t);

	/* compute mean strain */
	compute_s_ij(c,t);

	/* compute anisotropy tensor */
	for (m=0; m<3; m++) {
		for (n=0; n<3; n++) {
			a_ij[m][n] =  0.5*my_rsm[m][n]/my_tke - delta_ij[m][n]/3.;
		}
	}

	/* compute eingenvalue/eigenvector decomposition */
	eigen_decomposition(a_ij,eigv,eigs);
	/* eigenvalues are automatically sorted by QR algorithm
	 * such that eigs[2] > eigs[1] > eigs[0]
	 */

	/* compute convex combination coefficients */
	double c1c = eigs[2] - eigs[1];
	double c2c = 2.0 * (eigs[1] - eigs[0]);
	double c3c = 3.0 * eigs[0] + 1.0;

	/* define barycentric coordinates */
	bary_coordinates[0] = corner[0][0] * c1c + corner[1][0] * c2c + corner[2][0] * c3c;
	bary_coordinates[1] = corner[0][1] * c1c + corner[1][1] * c2c + corner[2][1] * c3c;
	bary_coordinates[2] = 0.0;

	/*-------------------------------------------------------------*/
	/* uncertainty injection - start                               */
	/*-------------------------------------------------------------*/


	/* -----------------------
	 * Eigenvalue Modification
	 * -----------------------
	 * introduce perturbations in barycentric coordinates
	 * should be defined in C_UDSI(c,t,SENSOR_00), 01
	 */

	double new_bcoord[2];

	int COMPONENTIALITY = RP_Get_Integer("uq/componentiality");

	if (COMPONENTIALITY == 1) {
		/* 1C turbulence */
		new_bcoord[0] = corner[0][0];
		new_bcoord[1] = corner[0][1];
	}
	else if (COMPONENTIALITY == 2) {
		/* 2C turbulence */
		new_bcoord[0] = corner[1][0];
		new_bcoord[1] = corner[1][1];
	}
	else if (COMPONENTIALITY == 3) {
		/* 3C turbulence */
		new_bcoord[0] = corner[2][0];
		new_bcoord[1] = corner[2][1];
	}


	bary_coordinates[0] = (1.0-f_switch(c,t)) * bary_coordinates[0] + f_switch(c,t) * new_bcoord[0];
	bary_coordinates[1] = (1.0-f_switch(c,t)) * bary_coordinates[1] + f_switch(c,t) * new_bcoord[1];

	/* -----------------------
	 * Eigenvector Modification
	 * -----------------------
	 * introduce perturbations in the eigenvectors
	 * should be defined in C_UDSI(c,t,SENSOR_20), _21, _22
	 */

	/* Pull angle rotations from journal file */
	double theta = RP_Get_Real("uq/theta_perturbation")*M_PI/180.0;
	double phi   = RP_Get_Real("uq/phi_perturbation") * M_PI/180.0;
	double psi   = RP_Get_Real("uq/psi_perturbation") * M_PI/180.0;

	double cost = cos(theta);
	double sint = sin(theta);
	double cosf = cos(phi);
	double sinf = sin(phi);
	double cosp = cos(psi);
	double sinp = sin(psi);

	rotation_ij[0][0] =  cost*cosp;
	rotation_ij[0][1] = -cosf*sinp+sinf*sint*cosp;
	rotation_ij[0][2] =  sinf*sinp+cosf*sint*cosp;
	rotation_ij[1][0] =  cost*sinp;
	rotation_ij[1][1] =  cosf*cosp+sinf*sint*sinp;
	rotation_ij[1][2] = -sinf*cosp+cosf*sint*sinp;
	rotation_ij[2][0] = -sint;
	rotation_ij[2][1] =  sinf*cost;
	rotation_ij[2][2] =  cosf*cost;

	for (m=0; m<3; m++) {
		for (n=0; n<3; n++) {
			new_eigv[m][n] = 0.0;
			for (k=0; k<3; k++) {
				new_eigv[m][n] += eigv[m][k] * rotation_ij[k][n];
			}
		}
	}

	for (m=0; m<3; m++) {
		for (n=0; n<3; n++) {
			eigv[m][n] = (1.0-f_switch(c,t)) * eigv[m][n] +  f_switch(c,t) * new_eigv[m][n];
		}
	}


	/* -----------------------
	 * TKE Modification
	 * -----------------------
	 * should be defined in C_UDSI(c,t,SENSOR_1)
	 */

	double tke_perturbation = RP_Get_Real("uq/tke_perturbation");

	new_tke = my_tke * (1.0+f_switch(c,t)*tke_perturbation);

	/*-------------------------------------------------------------*/
	/* uncertainty injection - end                                 */
	/*-------------------------------------------------------------*/

	/* rebuild c1c,c2c,c3c based on new barycentric coordinates */
	c3c = bary_coordinates[1] / corner[2][1];
	c1c = bary_coordinates[0] - corner[2][0] * c3c;
	c2c = 1 - c1c - c3c;

	C_UDMI(c,t,C1) = c1c;
	C_UDMI(c,t,C2) = c2c;
	C_UDMI(c,t,C3) = c3c;

	/* build new anisotropy eigenvalues */
	eigs[0] = (c3c - 1) / 3.0;
	eigs[1] = 0.5 *c2c + eigs[0];
	eigs[2] = c1c + eigs[1];

	/* build new anisotropy tensor in two steps */
	/* step 1 >>> tmp_ij = eigv_ij * eigs_ij */
	for (i=0; i<3; i++) {
		for (j=0; j<3; j++) {
			tmp[i][j] = 0.0;
			for (m=0; m<3; m++) {
				tmp[i][j] += eigv[i][m]*eigs[m]*delta_ij[m][j];
			}
		}
	}
	/* step 2 >>> a_ij = tmp_ij * eigv_ij^T */
	for (i=0; i<3; i++) {
		for (j=0; j<3; j++) {
			a_ij[i][j] = 0.0;
			for (m=0; m<3; m++) {
				a_ij[i][j] += tmp[i][m]*eigv[j][m];
			}
		}
	}

	/* build new reynolds stresses */
	for (i=0; i<3; i++) {
		for (j=0; j<3; j++) {
			new_rsm[i][j] = 2.0*new_tke*(a_ij[i][j] + 1.0/3.0*delta_ij[i][j]);
		}
	}

}

/*-------------------------------------------------------*/
/* Fleunt UDFs                                           */
/*-------------------------------------------------------*/

/* -----------------------
 * Momentum Source Terms
 * -----------------------*/
DEFINE_SOURCE(u_source, c, t, dS, eqn)
{
	face_t f;
	cell_t cv0, cv1;
	Thread *tf, *t_cv0, *t_cv1;
	double d11_cv0, d12_cv0, d13_cv0;
	double d11_cv1, d12_cv1, d13_cv1;
	double d11_f, d12_f, d13_f;
	double div;
	int n,orient;
	double A[3];

	div = 0.0;
	orient = 1;
	/* Loop over all faces */
	c_face_loop(c,t,n){
		/* current face */
		f = C_FACE(c,t,n);
		tf = C_FACE_THREAD(c,t,n);
		if (!BOUNDARY_FACE_THREAD_P(tf)) {
			F_AREA(A,f,tf);

			cv0 = F_C0(f,tf);
			if (cv0 == c) orient = 1;
			t_cv0 = THREAD_T0(tf);

			d11_cv0 = C_UDMI(cv0,t_cv0,D11);
			d12_cv0 = C_UDMI(cv0,t_cv0,D12);
			d13_cv0 = C_UDMI(cv0,t_cv0,D13);

			cv1 = F_C1(f,tf);
			if (cv1 == c) orient = -1;
			t_cv1 = THREAD_T1(tf);

			d11_cv1 = C_UDMI(cv1,t_cv1,D11);
			d12_cv1 = C_UDMI(cv1,t_cv1,D12);
			d13_cv1 = C_UDMI(cv1,t_cv1,D13);

			d11_f = 0.5*(d11_cv0+d11_cv1);
			d12_f = 0.5*(d12_cv0+d12_cv1);
			d13_f = 0.5*(d13_cv0+d13_cv1);

			div += (d11_f*A[0] + d12_f*A[1] + d13_f*A[2])*orient;
		}
	}
	dS[eqn] = 0.;
	return div / C_VOLUME(c,t);


}

DEFINE_SOURCE(v_source, c, t, dS, eqn)
{
	face_t f;
	cell_t cv0, cv1;
	Thread *tf, *t_cv0, *t_cv1;
	double d21_cv0, d22_cv0, d23_cv0;
	double d21_cv1, d22_cv1, d23_cv1;
	double d21_f, d22_f, d23_f;
	double div;
	int n,orient;
	double A[3];

	div = 0.0;
	orient = 1;
	c_face_loop(c,t,n){
		f = C_FACE(c,t,n);
		tf = C_FACE_THREAD(c,t,n);
		if (!BOUNDARY_FACE_THREAD_P(tf)) {
			F_AREA(A,f,tf);

			cv0 = F_C0(f,tf);
			if (cv0 == c) orient = 1;
			t_cv0 = THREAD_T0(tf);

			d21_cv0 = C_UDMI(cv0,t_cv0,D12);
			d22_cv0 = C_UDMI(cv0,t_cv0,D22);
			d23_cv0 = C_UDMI(cv0,t_cv0,D23);

			cv1 = F_C1(f,tf);
			if (cv1 == c) orient = -1;
			t_cv1 = THREAD_T1(tf);

			d21_cv1 = C_UDMI(cv1,t_cv1,D12);
			d22_cv1 = C_UDMI(cv1,t_cv1,D22);
			d23_cv1 = C_UDMI(cv1,t_cv1,D23);

			d21_f = 0.5*(d21_cv0+d21_cv1);
			d22_f = 0.5*(d22_cv0+d22_cv1);
			d23_f = 0.5*(d23_cv0+d23_cv1);

			div += (d21_f*A[0] + d22_f*A[1] + d23_f*A[2])*orient;
		}
	}
	dS[eqn] = 0.;
	return div / C_VOLUME(c,t);


}

DEFINE_SOURCE(w_source, c, t, dS, eqn)
{
	face_t f;
	cell_t cv0, cv1;
	Thread *tf, *t_cv0, *t_cv1;
	double d31_cv0, d32_cv0, d33_cv0;
	double d31_cv1, d32_cv1, d33_cv1;
	double d31_f, d32_f, d33_f;
	double div;
	int n,orient;
	double A[3];

	div = 0.0;
	orient = 1;
	c_face_loop(c,t,n){
		f = C_FACE(c,t,n);
		tf = C_FACE_THREAD(c,t,n);
		if (!BOUNDARY_FACE_THREAD_P(tf)) {
			F_AREA(A,f,tf);

			cv0 = F_C0(f,tf);
			if (cv0 == c) orient = 1;
			t_cv0 = THREAD_T0(tf);

			d31_cv0 = C_UDMI(cv0,t_cv0,D13);
			d32_cv0 = C_UDMI(cv0,t_cv0,D23);
			d33_cv0 = C_UDMI(cv0,t_cv0,D33);

			cv1 = F_C1(f,tf);
			if (cv1 == c) orient = -1;
			t_cv1 = THREAD_T1(tf);

			d31_cv1 = C_UDMI(cv1,t_cv1,D13);
			d32_cv1 = C_UDMI(cv1,t_cv1,D23);
			d33_cv1 = C_UDMI(cv1,t_cv1,D33);

			d31_f = 0.5*(d31_cv0+d31_cv1);
			d32_f = 0.5*(d32_cv0+d32_cv1);
			d33_f = 0.5*(d33_cv0+d33_cv1);

			div += (d31_f*A[0] + d32_f*A[1] + d33_f*A[2])*orient;
		}
	}
	dS[eqn] = 0.;
	return div / C_VOLUME(c,t);


}

/* -----------------------
 * k-equation Source Term
 * -----------------------*/
DEFINE_SOURCE(k_source, c, t, dS, eqn)
{
	double c_k, c_d;
	double mu_t, G_k;

	c_k = MAX(C_UDSI(c,t,K), SMALL_NUMBER);
	c_d = MAX(C_UDSI(c,t,D), SMALL_NUMBER);

	mu_t = ev(c,t);
	G_k = mu_t*SQR(Strainrate_Mag(c,t));

	dS[eqn] = -2.*C_R(c,t)*C_R(c,t)*C_MU*f_mu(c,t)*c_k/mu_t;
	return G_k - C_R(c,t)*C_R(c,t)*C_MU*f_mu(c,t)*SQR(c_k)/mu_t;
}

/* -----------------------
 * k-equation Dissipation Term
 * -----------------------*/
DEFINE_DIFFUSIVITY(k_diffusivity, c, t, eqn)
{
	double diff;
	double mu = C_MU_L(c,t);
	double mu_t = ev(c,t);

	diff = mu_t/SIG_K + mu;
	return diff;
}

/* -----------------------
 * epsilon-equation Source Term
 * -----------------------*/
DEFINE_SOURCE(d_source, c, t, dS, eqn)
{
	double c_k, c_d;
	double mu_t,G_k;

	c_k = MAX(C_UDSI(c,t,K), SMALL_NUMBER);
	c_d = MAX(C_UDSI(c,t,D), SMALL_NUMBER);

	mu_t = ev(c,t);
	G_k = mu_t*SQR(Strainrate_Mag(c,t));

	dS[eqn] = C1_D*f_1(c,t)*G_k/c_k
			- 2.*C2_D*f_2(c,t)*C_R(c,t)*c_d/c_k;
	return C1_D*f_1(c,t)*G_k*c_d/c_k
			- C2_D*f_2(c,t)*C_R(c,t)*SQR(c_d)/c_k;
}

/* -----------------------
 * epsilon-equation Dissipation Term
 * -----------------------*/
DEFINE_DIFFUSIVITY(d_diffusivity, c, t, eqn)
{
	double diff;
	double mu = C_MU_L(c,t);
	double mu_t = ev(c,t);

	diff = mu_t/SIG_D + mu;
	return diff;
}

/* Set the turbulent viscosity */
DEFINE_TURBULENT_VISCOSITY(ke_mut, c, t)
{
	double mu_t = ev(c,t);
	return mu_t;
}

DEFINE_PROFILE(wall_d_bc, t, position)
{
	face_t f;
	cell_t c0;
	Thread *t0 = t->t0; /* t0 is cell thread */
	double xw[ND_ND], xc[ND_ND], dx[ND_ND], rootk, dy, drootkdy;

	/* Do nothing if wall distance not computed or not in fluid zone */
	if (!Data_Valid_P() || !FLUID_THREAD_P(t0)) return;

	begin_f_loop(f,t)
	{
		c0 = F_C0(f,t);
		rootk = sqrt(MAX(C_UDSI(c0,t0,K), SMALL_NUMBER));
		F_CENTROID(xw,f,t);
		C_CENTROID(xc,c0,t0);
		NV_VV(dx, =, xc, -, xw);
		dy = ND_MAG(dx[0], dx[1], dx[2]);
		drootkdy = rootk/dy;
		F_PROFILE(f,t,position) = 2.*C_MU_L(c0,t0)/C_R(c0,t0)*drootkdy*drootkdy;
	}
	end_f_loop(f,t)
}

DEFINE_ADJUST(abid_adjust, domain)
{
	Thread *t;
	cell_t c;

	double URLX =  RP_Get_Real("uq/shift");
	thread_loop_c (t, domain)
	begin_c_loop(c,t) {

		compute_abid_rsm_ij(c,t);

		compute_barycentric_map(c,t,abid_tke,abid_rsm);

		C_K(c,t) = abid_tke;
		C_D(c,t) = C_UDSI(c,t,D);


		C_UDMI(c,t,D11) = -URLX*(new_rsm[0][0] - abid_rsm[0][0]);
		C_UDMI(c,t,D12) = -URLX*(new_rsm[0][1] - abid_rsm[0][1]);
		C_UDMI(c,t,D13) = -URLX*(new_rsm[0][2] - abid_rsm[0][2]);
		C_UDMI(c,t,D22) = -URLX*(new_rsm[1][1] - abid_rsm[1][1]);
		C_UDMI(c,t,D23) = -URLX*(new_rsm[1][2] - abid_rsm[1][2]);
		C_UDMI(c,t,D33) = -URLX*(new_rsm[2][2] - abid_rsm[2][2]);

		C_UDMI(c,t,R11) = new_rsm[0][0];
		C_UDMI(c,t,R12) = new_rsm[0][1];
		C_UDMI(c,t,R13) = new_rsm[0][2];
		C_UDMI(c,t,R22) = new_rsm[1][1];
		C_UDMI(c,t,R23) = new_rsm[1][2];
		C_UDMI(c,t,R33) = new_rsm[2][2];
	}
	end_c_loop(c,t)
}

DEFINE_ADJUST(rsm_adjust, domain)
{
	Thread *t;
	cell_t c;
	double rsm_rsm[3][3],rsm_tke;
	double URLX =  RP_Get_Real("uq/shift");


	thread_loop_c (t, domain)
	begin_c_loop(c,t) {

		rsm_rsm[0][0] = C_RUU(c,t);
		rsm_rsm[1][1] = C_RVV(c,t);
		rsm_rsm[2][2] = C_RWW(c,t);
		rsm_rsm[0][1] = C_RUV(c,t);
		rsm_rsm[0][2] = C_RUW(c,t);
		rsm_rsm[1][2] = C_RVW(c,t);
		rsm_rsm[1][0] = rsm_rsm[0][1];
		rsm_rsm[2][0] = rsm_rsm[0][2];
		rsm_rsm[2][1] = rsm_rsm[1][2];
		rsm_tke = 0.5*(C_RUU(c,t)+C_RVV(c,t)+C_RWW(c,t));

		compute_barycentric_map(c,t,rsm_tke,rsm_rsm);

		/*
      C_UDMI(c,t,D11) = -URLX*(new_rsm[0][0] - rsm_rsm[0][0]);
      C_UDMI(c,t,D12) = -URLX*(new_rsm[0][1] - rsm_rsm[0][1]);
      C_UDMI(c,t,D13) = -URLX*(new_rsm[0][2] - rsm_rsm[0][2]);
      C_UDMI(c,t,D22) = -URLX*(new_rsm[1][1] - rsm_rsm[1][1]);
      C_UDMI(c,t,D23) = -URLX*(new_rsm[1][2] - rsm_rsm[1][2]);
      C_UDMI(c,t,D33) = -URLX*(new_rsm[2][2] - rsm_rsm[2][2]);

      C_UDMI(c,t,R11) = new_rsm[0][0];
      C_UDMI(c,t,R12) = new_rsm[0][1];
      C_UDMI(c,t,R13) = new_rsm[0][2];
      C_UDMI(c,t,R22) = new_rsm[1][1];
      C_UDMI(c,t,R23) = new_rsm[1][2];
      C_UDMI(c,t,R33) = new_rsm[2][2];
		 */
		C_RUU(c,t) = URLX*new_rsm[0][0] + (1.0 - URLX)*rsm_rsm[0][0];
		C_RVV(c,t) = URLX*new_rsm[1][1] + (1.0 - URLX)*rsm_rsm[1][1];
		C_RWW(c,t) = URLX*new_rsm[2][2] + (1.0 - URLX)*rsm_rsm[2][2];
		C_RUV(c,t) = URLX*new_rsm[0][1] + (1.0 - URLX)*rsm_rsm[0][1];
		C_RUW(c,t) = URLX*new_rsm[0][2] + (1.0 - URLX)*rsm_rsm[0][2];
		C_RVW(c,t) = URLX*new_rsm[1][2] + (1.0 - URLX)*rsm_rsm[1][2];
	}
	end_c_loop(c,t)
}

/*-------------------------------------------*/
/* routines for the eigenvalue decomposition */
/*-------------------------------------------*/

void tred2(double V[3][3], double d[3], double e[3]) {

	int i,j,k;
	/*  This is derived from the Algol procedures tred2 by        */
	/*  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for     */
	/*  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding */
	/*  Fortran subroutine in EISPACK.                            */

	for (j = 0; j < 3; j++) {
		d[j] = V[3-1][j];
	}

	/* Householder reduction to tridiagonal form. */

	for (i = 3-1; i > 0; i--) {

		/* Scale to avoid under/overflow. */

		double scale = 0.0;
		double h = 0.0;
		for (k = 0; k < i; k++) {
			scale = scale + fabs(d[k]);
		}
		if (scale == 0.0) {
			e[i] = d[i-1];
			for (j = 0; j < i; j++) {
				d[j] = V[i-1][j];
				V[i][j] = 0.0;
				V[j][i] = 0.0;
			}
		} else {

			/* Generate Householder vector. */

			for (k = 0; k < i; k++) {
				d[k] /= scale;
				h += d[k] * d[k];
			}
			double f = d[i-1];
			double g = sqrt(h);
			if (f > 0) {
				g = -g;
			}
			e[i] = scale * g;
			h = h - f * g;
			d[i-1] = f - g;
			for (j = 0; j < i; j++) {
				e[j] = 0.0;
			}

			/* Apply similarity transformation to remaining columns. */

			for (j = 0; j < i; j++) {
				f = d[j];
				V[j][i] = f;
				g = e[j] + V[j][j] * f;
				for (k = j+1; k <= i-1; k++) {
					g += V[k][j] * d[k];
					e[k] += V[k][j] * f;
				}
				e[j] = g;
			}
			f = 0.0;
			for (j = 0; j < i; j++) {
				e[j] /= h;
				f += e[j] * d[j];
			}
			double hh = f / (h + h);
			for (j = 0; j < i; j++) {
				e[j] -= hh * d[j];
			}
			for (j = 0; j < i; j++) {
				f = d[j];
				g = e[j];
				for (k = j; k <= i-1; k++) {
					V[k][j] -= (f * e[k] + g * d[k]);
				}
				d[j] = V[i-1][j];
				V[i][j] = 0.0;
			}
		}
		d[i] = h;
	}

	/* Accumulate transformations. */

	for (i = 0; i < 3-1; i++) {
		V[3-1][i] = V[i][i];
		V[i][i] = 1.0;
		double h = d[i+1];
		if (h != 0.0) {
			for (k = 0; k <= i; k++) {
				d[k] = V[k][i+1] / h;
			}
			for (j = 0; j <= i; j++) {
				double g = 0.0;
				for (k = 0; k <= i; k++) {
					g += V[k][i+1] * V[k][j];
				}
				for (k = 0; k <= i; k++) {
					V[k][j] -= g * d[k];
				}
			}
		}
		for (k = 0; k <= i; k++) {
			V[k][i+1] = 0.0;
		}
	}
	for (j = 0; j < 3; j++) {
		d[j] = V[3-1][j];
		V[3-1][j] = 0.0;
	}
	V[3-1][3-1] = 1.0;
	e[0] = 0.0;
}

/* Symmetric tridiagonal QL algorithm */
void tql2(double V[3][3], double d[3], double e[3]) {

	int i,j,k,l;
	for (i = 1; i < 3; i++) {
		e[i-1] = e[i];
	}
	e[3-1] = 0.0;

	double f = 0.0;
	double tst1 = 0.0;
	double eps = pow(2.0,-52.0);
	for (l = 0; l < 3; l++) {

		/* Find small subdiagonal element */

		tst1 = MAX(tst1,(fabs(d[l]) + fabs(e[l])));
		int m = l;
		while (m < 3) {
			if (fabs(e[m]) <= eps*tst1) {
				break;
			}
			m++;
		}

		/* If m == l, d[l] is an eigenvalue, */
		/* otherwise, iterate.               */

		if (m > l) {
			int iter = 0;
			do {
				iter = iter + 1;  /* (Could check iteration count here.) */

				/* Compute implicit shift */

				double g = d[l];
				double p = (d[l+1] - g) / (2.0 * e[l]);
				double r = sqrt(p*p+1.0);
				if (p < 0) {
					r = -r;
				}
				d[l] = e[l] / (p + r);
				d[l+1] = e[l] * (p + r);
				double dl1 = d[l+1];
				double h = g - d[l];
				for (i = l+2; i < 3; i++) {
					d[i] -= h;
				}
				f = f + h;

				/* Implicit QL transformation. */

				p = d[m];
				double c = 1.0;
				double c2 = c;
				double c3 = c;
				double el1 = e[l+1];
				double s = 0.0;
				double s2 = 0.0;
				for (i = m-1; i >= l; i--) {
					c3 = c2;
					c2 = c;
					s2 = s;
					g = c * e[i];
					h = c * p;
					r = sqrt(p*p+e[i]*e[i]);
					e[i+1] = s * r;
					s = e[i] / r;
					c = p / r;
					p = c * d[i] - s * g;
					d[i+1] = h + s * (c * g + s * d[i]);

					/* Accumulate transformation. */

					for (k = 0; k < 3; k++) {
						h = V[k][i+1];
						V[k][i+1] = s * V[k][i] + c * h;
						V[k][i] = c * V[k][i] - s * h;
					}
				}
				p = -s * s2 * c3 * el1 * e[l] / dl1;
				e[l] = s * p;
				d[l] = c * p;

				/* Check for convergence. */

			} while (fabs(e[l]) > eps*tst1);
		}
		d[l] = d[l] + f;
		e[l] = 0.0;
	}

	/* Sort eigenvalues and corresponding vectors. */

	for (i = 0; i < 3-1; i++) {
		k = i;
		double p = d[i];
		for (j = i+1; j < 3; j++) {
			if (d[j] < p) {
				k = j;
				p = d[j];
			}
		}
		if (k != i) {
			d[k] = d[i];
			d[i] = p;
			for (j = 0; j < 3; j++) {
				p = V[j][i];
				V[j][i] = V[j][k];
				V[j][k] = p;
			}
		}
	}
}

void eigen_decomposition(double A[3][3], double V[3][3], double d[3]) {
	int i,j;
	double e[3];
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			V[i][j] = A[i][j];
		}
	}
	tred2(V, d, e);
	tql2(V, d, e);
}

/*----------------------------------------------------------------*/
/* EUQ perturbation of the Reynolds Stresses - end                */
/*----------------------------------------------------------------*/
